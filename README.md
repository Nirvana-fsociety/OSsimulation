# 可视化仿真实现作业管理与虚页内存管理

## 摘要

本人使用Java程序设计语言仿真实现可视化仿真实现作业管理与虚页内存管理。

在项目中，本人力求设计思想贴近教材，从而达到深入理解教材中的基础知识。在实践过程中理解诸如死锁检测算法、死锁恢复方式、伙伴算法分配连续内存页框、LRU页面替换算法等操作系统知识。

## 主要完成的功能

能够支持8个进程运行的操作系统仿真程序。

界面的可视化。可视化部分包括：三级调度的可视化、伙伴算法动态回收和分配内存页框的仿真、指令执行过程和系统运行过程的运行细节报告、CPU、MMU、DMA部件、页表。

整个系统由6个线程的共同构成。运行过程包括：进程指令执行与三级调度线程、时钟及死锁检测线程、DMA传输线程、作业管理线程、请求创建作业线程、界面刷新线程。

模拟了计算机系统硬件，包括：地址总线、数据总线、CPU、MMU、时钟、DMA、主存、辅存。在计算机硬件模拟的基础上实现了三级调度。 

在三级调度的过程中，实现了进程原语，包括：挂起、激活、阻塞、唤醒、撤销、创建。也实现了MMU地址转换、页表的生成。

拥有5种详细设计的系统特权程序：Ｐ操作、V操作、缺页异常处理、DMA赋值启动程序、DMA输入善后程序。以及４种转为系统调用触发指令设计的无实际内容的普通系统调用。还实现了三类中断处理程序：包括DMA传输完成中断处理、时钟中断处理以及死锁检测中断处理程序。

在存储管理过程中实现了通过伙伴算法分配回收内存物理页框以及基于LRU算法的虚页存储管理。在进程调度过程中实现了死锁检测与死锁恢复。同时还实现了进程之间的互斥争夺资源，以及外部设备与进程之间的同步。其中进程调度全程由执行的指令集来决定，本人设计的指令较为细致具体，包括访存指令、输入指令、计算指令、输出指令、跳转指令、系统调用触发指令以及一条普通指令。每一种指令都能触发不同的系统行为。

## 核心设计

本人作品的核心设计为三个部分：进程管理系统、详细的指令系统和独特的资源管理器。

进程管理子系统是系统的核心部分，根据当前执行的指令，通过进程原语，对进程进行三态调度，在逐条执行指令的过程中触发系统调用及包括死锁检测在内的中断处理程序，根据内存资源的充裕程度还能触发中级调度。进程管理子系统包含了存储管理子系统，存储管理子系统的核心是伙伴算法分配物理页框和基于LRU算法和缺页异常处理的虚存管理。

独特的指令集系统在不超出设计范围的前提下尽量丰富、详细且具体，每种指令都能促成系统的状态转换和多种系统特权程序执行等不同处理行为。

资源管理器则对进程之间争夺的资源进行集中的管理，并且负责死锁检测程序和PV操作的具体实现。

## 关键词
进程管理、死锁检测、指令系统、可视化、虚页管理。

## 1	实践内容与目标

### 1.1	实践内容

本此课程设计的时间内容为“可视化仿真实现作业管理与虚页内存管理”，内容主要为通过多个作业创建为对应进程在系统中调度，从而仿真实现操作系统中的多任务并发环境。

1)	仿真实现作业及进程的并发环境，本人实现了最多八个进程同时进入系统参与调度；

2)	MMU地址变换，本人实现了通过CPU发送逻辑地址给MMU并在MMU过程中转换为物理地址、然后根据得到的物理地址访存的过程，其中还实现了缺页异常及其处理程序。

3)	实现的进程原语主要包括：挂起、激活、阻塞、唤醒、撤销、创建。而进程的三级调度就是依赖于上述进程原语实现的。

4)	实现了虚存管理，实现的基础是缺页异常及其处理程序及LRU页面替换算法。

5)	实现了物理内存的分配与回收，主要依赖于伙伴算法实现。

6)	本人实现了5种详细设计的系统特权程序：PV操作、缺页异常处理、DMA赋值启动程序、DMA输入善后程序。以及一种转为系统调用触发指令设计的无实际内容的普通系统调用。其中以PV操作为基础实现了进程间的互斥争夺资源。

7)	此外，本人还实现了3种精心设计的中断处理程序，包括时钟中断处理程序、DMA中断信号处理程序和死锁检测处理程序。其中死锁检测处理程序用在了实现死锁检测的过程中。

8)	同时本人还依照计算机底层指令集的格式设计了一个拥有７种指令的指令系统，包括输入指令、输出指令、访存指令、计算指令、系统调用触发指令和普通指令。其中输入输出指令都依赖于DMA于请求输入进程的生产者消费者同步实现，而前５种指令都会涉及到PV操作从而互斥争夺资源。访存指令还能触发存取数据时的缺页异常。系统调用触发指令则特意为了触发一般的系统调用而设计。普通指令则模拟量占用１秒运行实际的空操作。

9)	参照教材上对管程的描述，实现了一个类似于管程的资源管理器。用于集中管理进程争夺的有限资源。此外该资源管理器也是死锁检测和PV操作的实际操作模块。

10)	实现死锁检测和死锁恢复：分别依赖于根据时钟信号定时发起的死锁检测程序和发现死锁后的恢复操作。本人在设计死锁恢复的过程中，摒弃了代价较大、但是简便易行的撤销所有死锁进程的做法，而是采用了代价较小、但是实现起来较为复杂的剥夺死锁进程资源并回滚一条指令的策略。

11)	此外，本人还顺利实现了可视化过程，包括进程控制块、PCB池、就绪队列、阻塞队列、挂起就绪队列、挂起阻塞队列以及当前运行PCB的可视化。另外还实现了主要硬件：时钟、CPU内部关键寄存器、MMU内部结构（包括快表TLB）、主存、DMA内部结构的可视化。其中对主存的可视化主要是通过讲伙伴算法的运行过程动态显示实现的。另外还通过细致复杂的页表结构实现了虚存管理的可视化。还实现了系统运行过程的细节报告可视化，即显示出日志文件的生成过程。

### 1.2	实践目标

本人的实践目标是，通过实际的Java程序，尽可能依照教材实现一个完整而全面的仿真操作系统软件。在实现过程中尽量符合操作系统的理论，做细致详细合理的设计。在实践过程中将操作系统中抽象的算法，如：伙伴算法分配回收内存页框、死锁检测算法如何发现死锁、LRU算法如何在实际中替换驻留集中的页面，通过代码实现显得具象，并使得本人能够深入理解其中的原理。

该系统的功能模块划分为：

1)	计算机底层硬件模块：为多进程管理的系统环境提供硬件支持；

2)	作业管理子系统：将未来请求序列中的请求创建为作业，并维护作业后备队列。

3)	存储管理子系统：为多进程管理的实现提供内存分配与回收、虚页管理、数据存储指令读取等功能支持。

4)	资源管理器：一个类似于管程的资源管理器，对各种资源进行集中管理，每一个资源对应一个或多个信号量，每个资源设定了特定的数量，并建立了等待该资源的进程等待队列。并且负责实现PV操作，死锁检测的实现。

5)	指令系统：详尽具体的指令系统应用于系统运行过程中，能够完全发挥操作系统的功能，一条指令复杂到能促使进程实现多次三态转换，细致到执行一条指令从开始到结束可以触发多种系统调用指令。

6)	进程管理系统：基于上述硬件模块、存储管理系统、资源管理器和指令系统这四大功能模块，对进程进行三级调度，从而实现多任务并发的系统环境。


## 2 硬件仿真设计

### 2.1	CPU

本人设计的CPU包括程序计数器PC、指令寄存器IR、状态位寄存器PSW、地址寄存器AR和栈顶指针寄存器SP。每个寄存器存储的数据都为16bit，但是功能各不相同

#### 2.1.1	程序计数器PC

主要功能是存放要执行的下一条指令的逻辑地址，并且有自动加一的功能和接收外来数据和返回PC内部数据的功能。

#### 2.1.2	指令寄存器IR

主要功能是存放当前执行的指令内容，并且拥有从16位二进制指令中提取指令表达的信息的功能。对于任何指令，IR都提取其高三位识别码先识别该指令种类，在得到指令种类之后再根据其种类提取识别码后面的操作字段。对于不同的指令IR寄存器提取的操作字段不同：

1)	如果是输入指令或输出指令，IR能够提取外存文件地址；

2)	如果是系统调用指令，IR能够提取系统调用编号；

3)	如果是访存指令，能够提取目的寄存器编号和以进程映像起始逻辑地址为基址的访存偏移量；

4)	如果是计算指令，则能够提取目的寄存器编号和源寄存器编号；

5)	如果是跳转指令，则能够提取以当前PC内存储指令地址为基址的偏移量；

6)	如果是普通指令，则没有访问字段。

经过对指令的字段提取，就可以按照获得的指令信息执行指令。

#### 2.1.3	状态位寄存器PSW

再仿真系统实现的过程中，只负责记录当前CPU的状态是内核态还是用户态。提供系统用户切换的功能。

#### 2.1.4	地址寄存器AR
	因为本人设计来访存指令，而访存指令就要读取内存中数据段的某一个位置，如果数据段尚未被调入，还可以触发缺页异常，并且切换为内核态执行缺页异常处理程序，所以必须明确每一条访存指令访存的逻辑地址。AR寄存器就是为了存放用于访存数据段的16位逻辑地址而设计的。提供将地址写入AR寄存器和从AR寄存器读出地址的功能。

#### 2.1.5	栈顶指针寄存器SP

SP寄存器同样存储16位逻辑地址，指示当前运行的进程保存现场的核心栈的栈顶所在的逻辑地址单元。提供有压栈过程中的地址自增、弹栈过程中的地址自减和读取写入地址的功能。

### 2.2	MMU

MMU的主要结构为用于输入的逻辑地址寄存器和用于输出物理地址寄存器，存放当前运行进程的页表基址的寄存器。以及快表TLB。MMU的工作方式为从MMU外部（CPU的PC寄存器或AR寄存器）输入要访问的16位逻辑地址，然后再MMU内部对该地址解析出7位逻辑页号和9位地址偏移。根据逻辑页号查找快表，得到该逻辑页号当前对应的6位物理页号，将得到的物理页号与9位地址偏移拼接成15位物理地址存入物理地址寄存器中，向MMU外部的地址总线输出。

当然，在查找快表的过程中并不总是能够成功找到逻辑页号对应的物理页号。如果查找失败，将求助于MMU外部的页表，在页表中寻找物理页号。如果仍旧失败，就会触发缺页异常。上述过程的参考依据为教材220页对MMU结构的介绍。

### 2.3	地址总线

地址总线用于在硬件结构之间传送地址，包括逻辑地址的传送和物理地址的传送。CPU内部AR寄存器和PC寄存器中的逻辑地址将通过地址总线送往MMU的逻辑地址寄存器。MMU成功转换的物理地址将通过地址总线传送给内存，用于寻访内存的双字节存储单元。

### 2.4	数据总线

数据总线用于传输来自内存的进程正文段中的16位指令内容以及访存指令存取的16位数据。如果是指令内容，则送往CPU的指令寄存器IR，以供取指令后执行指令使用。如果是访存指令访存的数据，由于并没有设计通用寄存器没有位置可以存放，且访存指令的意义在于触发PV操作和数据访存过程，去除的数据没有实际价值，所以选择直接丢弃。

### 2.5	时钟

本人模拟的时钟具有多种功能：模拟了用来提示时间片已耗尽的时钟中断信号，检测后备作业队列是否有作业排队的提醒信号，死锁检测算法的检测时间提醒信号。目前本人设计的时间片长度位４秒，检测作业后备队里的时间长度位５秒，检测是否发生死锁的时间长度为９秒。在这些时刻，时钟都会向CPU发出硬件中断信号，并要求CPU停下当前的工作进行处理。

### 2.6	DMA

DMA是一个独立运行的处理器，能够与CPU同时运行。它主要负责CPU执行输入输出指令时的独立传输工作，进程只需要为DMA提供要读取的外设所在外存地址，传输方向、要传输字数和系统缓冲区地址然后触发DMA启动即可，CPU转而运行其他无关进程。DMA的具体的数据传输操作在CPU运行其他进程的同时进行。

基于上述功能设计，以及教材２５７页IO控制方式中DMA方式的介绍，本人模拟DMA的主要部件包括：系统缓冲区的物理地址寄存器、存放进程用户缓冲区物理地址的主存地址缓冲区。存放外设文件在外存中的地址的外设地址寄存器。计数从外设文件搬移到缓冲区的双字节数据个数的数据计数器。能在传输工作完成后向CPU汇报工作完成的中断信号发送部件。用于接收CPU启动信号的CPU信号接收部件。方向信号部件，CPU通过设置该部件的值来控制数据的传输方向，如果值是“真”表示CPU让DMA发起将系统缓冲区中数据搬运到外设所在文件。如果是“假”表示CPU让DMA将外设文件中的数据读入系统缓冲区。

### 2.7	主存

主存设计中，物理块总数为６４块，每块物理页框大小为５１２B。

#### 2.7.1	系统区

主存中系统区内存占用固定的３２块：０号页框～３１号页框。进一步细致划分为：

系统缓冲区	０号页框	１页

页表	１号页框	１页

PCB池	２～３号页框	２页

特权指令集	４～９号页框	６页

其中PCB池中一个PCB的尺寸大小为６４个双字节存储单元，所以容纳八个PCB的PCB池需要２个物理页框。模拟一个特权指令集的长度为１２８个双字节存储单元，其中包括３种硬件中断处理程序、５种本人详细设计的异常处理程序和４种没有实际操作的普通系统特权程序。共１２个，所以占用６页。

#### 2.7.2	用户区
	
用户区同样占用固定的３２块：３２号～６３号页框。其中每个进程允许主流在内存中的驻留集大小为一个进程８块物理内存。每个进程映像包括一个PCB进程控制块（存放在系统区），一个４页大小的进程正文段，一个２页大小的数据段，一个１页大小的用于保存现场的核心栈，一个１页大小的进程用户缓冲区，共８页的进程映像。在实际分配的过程中根据预调页操作和缺页异常处理两个方式动态分配用户区的内存块。

### 3.8	辅存

按照要求设置为２０４８个辅存扇区，我们将其分为３２个磁道，每个磁道分得６４个扇区，每个扇区按照设计要求，与主存物理页框等大，即５１２B。

对这２０４８个扇区的细致划分如下：

文件区	０～１７９９	１８００

设备文件区	１８００～１８０３	４

作业存储文件区	１８５６～１９１９	６４

交换区	１９２０～２０４７	１２８

其中，设备文件区和作业存储文件区被包括在文件区中。交换区与文件区共同构成整个辅存。

以上就是本人的全部硬件仿真内容，强调只设计有关于操作系统运行调度的部分，不刻意追求实现到最真实，但是完全能够作为支持操作系统运行的基础而不出现任何问题。




code文件夹：保存程序代码，包括：工程文件、源程序代码；并提供本文件夹每个文件的简单说明文件；
            OSProject1.0文件夹：
                              文件内容说明.txt：该文件夹内文件简介。
                              src文件夹：本人编写全部源程序，每个类都有一个Java源文件。
                              bin文件夹：装有本人编写全部类的.class文件。
                              Process.txt：系统运行日志文件
                              request.txt：程序中直接点击系统启动按钮自动生成的5个请求。可以根据该文件自动生成作业。
                              input文件夹：将测试用例文件夹中的文件放入该文件夹，系统就可以读入该测试用例。
                              MainMemory文件夹：主存文件夹，内部含有64个文本文件，模拟内存页框。
                              SubMemory文件夹：辅存文件夹，内部又32个磁道文件夹，每个文件夹都又64个扇区文本文件。
                              其他：eclipse编译器自带文件，如果调试则不可或缺。
doc文件夹：保存提交的文档清单。
          1-选题任务书：我选择的题目需要完成的功能。
          2-课程设计实践报告：详细介绍了我的项目的设计思想和具体实现细节，是该作品全部内容的文字体现。
          3-自测报告：具体测试数据、测试结果、正确性分析，以及对作品进行自我测试后，给予的自评内容。
          4-答辩汇报：PPT+讲解视频或者结合系统演示讲解视频。
          5-课设自测视频文件：自我测试的过程演示视频。
          6-程序安装及使用手册：包括：安装环境、方法、每个功能使用例子。
          7-讨论组讨论报告：与我选题相同的同学组成的讨论组的讨论内容。
test文件夹：即最后的作品所在文件夹，包括.jar可执行程序、测试用例文件和其他运行需要文件。
other文件夹：保存使用的第三方程序或框架的库文件。（此处我没有使用任何第三方库，所以为空）
由于内部由大量的.doc文件如实践报告，无法在网页上预览，文本文件中的中文下载后观看能保证没有乱码，所以这些文件请务必先下载再浏览。
