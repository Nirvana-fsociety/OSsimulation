package osPackage;

public class OSController {
	private CentralProcessingUnit CPU;
	//功能函数：中断处理程序
	public void InterruptionDeal(int interruptionID) {
			
	}
	//功能函数：执行当前指令（在指令填充到IR时已经被IR寄存器解析了，现在就是要执行当前指令的功能）
	public void executeRunningInstruction() {
		switch (this.CPU.getIR().getInstructionID()) {
		case INPUT:
		/*
			 * 	输入指令前半部分：
			 *	1.CPU转为核心态
			 *	2.执行P操作-申请占用核心缓冲区
			 *	3.成功占用，则CPU转回用户态。失败会怎样？？？阻塞吗？还是设置管程，阻塞在管程外？
			 *	4.让DMA工作：将外设的数据传输给内存内核缓冲区。
			 *	5.同时阻塞自己
			 *
			 *	后半部分：
			 *	1.进程被唤醒（这一步交由中断服务程序）
			 *	2.将核心缓冲区中的数据整块搬移到对应用户缓冲区
			 *	3.进程继续运行-CPU转为核心态
			 *	4.执行V操作-释放缓冲区
			 *	5.执行下一条指令
			 */
			break;
		case OUTPUT:
			/*
			 * 	输出指令前半部分：
			 * 	1.CPU转为核心态
			 * 	2.执行P操作-申请占用核心缓冲区
			 * 	3.成功占用，则CPU转回用户态。失败……
			 * 	4.将用户缓冲区中的数据整块转移到核心缓冲区
			 * 	5.让DMA工作：将核心缓冲区中的数据传输到外设
			 * 	6.同时阻塞自己
			 * 
			 * 	后半部分：
			 *	1.进程被唤醒（这一步交由中断服务程序）
			 *	2.进程继续运行-CPU转为核心态
			 *	3.执行V操作-释放缓冲区
			 *	4.执行下一条指令
			 */
			break;
		case SYSTEM_CALL:
			/*
			 * 	系统调用：
			 * 	1.CPU转为核心态，关中断
			 * 	2.根据指令提供的-内存页号找到映射表；
			 * 	3.根据指令提供的-系统调用标号找到映射表的一项；
			 * 	4.将该项的内容传回CPU的PC寄存器
			 * 	5.CPU开始执行系统指令集
			 * 	6.执行完所有指令后，CPU转回用户态
			 * 	7.继续执行下一条指令
			 */
			break;
		case CALCULATE:
			/*
			 * 	计算/赋值：
			 * 	1.CPU转为核心态
			 * 	2.执行P操作-根据指令提供的寄存器标识列表申请寄存器。
			 * 	3.成功占用，则CPU转回用户态。失败……
			 * 	4.占用若干毫秒，表示计算
			 * 	5.CPU转为核心态
			 * 	6.执行V操作-将寄存器释放。
			 * 	7.CPU转为用户态
			 * 	8.继续执行下一条指令。
			 */
			break;
		case ACCESS_MEMORY:
			/*
			 * 	访存：
			 * 	1.CPU转为核心态
			 * 	2.执行P操作-根据指令提供的寄存器标识列表申请寄存器.
			 * 	3.成功占用，则CPU转回用户态。失败……
			 * 	4.将地址放到AR寄存器中
			 *  5.如果缺页中断执行中断处理程序
			 *  6.占用若干毫秒，表示存数动作。
			 *  6.执行V操作-释放寄存器。
			 */
		case NORMAL:
			/*
			 * 	普通指令：
			 * 	占用1秒即可。
			 */
		default:
			break;
		}
	}
}
